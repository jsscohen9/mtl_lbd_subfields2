---
title: "Hippocampal Subfield Analysis"
author: "Jesse Cohen"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE, }
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, 
                      fig.path = "~/R_LBD Hippocampal subfields/Data/")

set.seed(0122023)

rm(list = ls())
```

# Libraries
```{r packages}
library(tidyverse)
library(table1)
library(gridExtra)
library(modelr)
library(gtsummary)
library(hrbrthemes)
library(viridis)
library(ggforce)
library(arsenal)
library(ggpubr)
library(MatchIt)
library(magrittr)
library(here)
library(randomForest)
library(janitor)
library(rattle)
library(corrr)
library(lobstr)       # Inspect R data structures.
library(FSelector)    # Feature selection, information.gain().
library(stringi)      # String concat operator %s+%.

```

# Data Import
```{r munge, cache = TRUE, cache.extra = tools::md5sum('munge.R')}
source(file = here("munge.R"))
```

<!-- ## Confirm AD_present is consistent for each INDDID -->
<!-- ```{r confirm concordant ad_present} -->
<!-- # Take biomarkers dataframe in which each row has single biomarker test for each INDDID  -->
<!-- # and make table with ad present or absent for each INDDID -->
<!-- df_ad_present <-  -->
<!--   biomarkers %>%  -->
<!--   select(INDDID, ad_present, diagnosis, ad_present, abc, PET_read, tau_abeta42_ratio, CSFDate) %>%  -->
<!--   filter(is.na(ad_present)==F) %>% #remove any rows with NAs -->
<!--   group_by(INDDID) %>%  -->
<!--   summarise(ad_dx_unique = mean(ad_present)) #if the mean is not 0 or 1 then it has conflicting ad_present  -->

<!-- #remove individuals with conflicting ad_present -->
<!-- df_ad_present <- -->
<!--   df_ad_present %>%  -->
<!--   filter(ad_dx_unique == 0 | ad_dx_unique == 1) %>%  -->
<!--   mutate(ad_present = ifelse(ad_dx_unique == 1, TRUE,  -->
<!--                              ifelse(ad_dx_unique == 0, FALSE, -->
<!--                                     NA))) %>%  -->
<!--   select(INDDID, ad_present) -->

<!-- d <- d %>% filter(INDDID %in% df_ad_present$INDDID | diagnosis == "Normal") #include only cases with clear ad_present status, as well as Normal controls -->

<!-- remove(df_ad_present) -->
<!-- ``` -->

# Data Import Template
```{r initialize}
# input
mri_selected_ashs <- read_rds(here("objects/mri_selected_ashs_all.RDS"))

# Initialise the dataset as per the template.
dsname <- "mri_selected_ashs"
ds     <- get(dsname)

ds %>% sample_frac()

glimpse(ds)
```

```{r export ids/sessions}
qc_ids <- mri_selected_ashs %>% select(subject = INDDID, 
                                       session = FlywheelSessionLabel)

write_delim(qc_ids, file = here("qc_ids.txt"))
```


Normalize variable names automatically
```{r}
# Capture the original variable names for use in plots.

vnames <- names(ds)

# Normalise the variable names.

ds %<>% clean_names(numerals="right")

# Confirm the results are as expected.

names(ds)

# Index the original variable names by the new names.

names(vnames) <- names(ds)

vnames

# Note the available variables.

vars <- names(ds) %T>% print()

```

Character variables 
```{r}
# Identify the character variables by index.

ds %>%
  sapply(is.character) %>%
  which() %T>%
  print() ->
chari

# Identify the character variables by name.

ds %>% 
  names() %>% 
  '['(chari) %T>% 
  print() ->
charc

# Observe the unique levels.

ds[charc] %>% sapply(unique)

# How many diagnoses are represented in the dataset.

ds$diagnosis %>% 
  unique() %>%
  length()

# Here is a list of diagnoses and their frequencies in the dataset
ds$diagnosis %>%
  table()
```

Convert character to numeric where needed
```{r}
# Identify the vairables to process.

cvars <- c("session_year")

# Check the current class of the variables.

ds[cvars] %>% sapply(class)
```
```{r}
# Convert to numeric.

ds[cvars] %<>% sapply(as.numeric)

# Review some random values.

sample(ds$session_year, 10)
```
Convert character to factor where needed
```{r}
# Review the distribution of observations across levels.

ds %>%
  select(diagnosis, sex, race, ad_present) %>%
  sapply(table)

```
```{r}
# Note the names of the desired variables.

ds %>% 
  select(diagnosis, sex, race, ad_present) %>% 
  names() %T>%
  print() ->
vnames

# Convert these variables from character to factor.

ds[vnames] %<>% 
  lapply(factor, ordered = FALSE) %>% 
  data.frame() %>% 
  as_tibble()

# Confirm they are now factors.

ds[vnames] %>% sapply(class)
```
```{r}
# Verify the distribution has not changed.

ds %>%
  select(all_of(vnames)) %>%
  sapply(table)

```

Numeric Variables
```{r}
ds %>%
  sapply(is.numeric) %>%
  which() %>%
  names %T>%
  print() ->
numi

ds[numi] %>% 
  summary()
```


```{r}
# Note the identifiers.

id <- c("inddid", "session_date", "flywheel_session_label")

# Initialise ignored variables: identifiers.

ignore <- c(id)

# Heuristic for candidate indentifiers to possibly ignore.

ds[vars] %>%
  sapply(function(x) x %>% unique() %>% length()) %>%
  equals(nrow(ds)) %>%
  which() %>%
  names() %T>%
  print() ->
ids

```
Once we have identified all of the variables to ignore we remove them from our list of variables to use.
```{r}
# Check the number of variables currently.

length(vars)

# Remove the variables to ignore.

vars <- setdiff(vars, ignore)

# Confirm they are now ignored.

length(vars)
```

# Data Exploration

A random sample of the dataset:
```{r}
ds %>% sample_frac()
```
 
Count groups:
```{r}
ds %>% count(diagnosis)

```


Constants
```{r}
# Identify variables that have a single value.

ds %>%
  select(all_of(vars)) %>%
  sapply(function(x) all(x == x[1L])) %>%
  which() %>%
  names() %T>%
  print() ->
constants

```

Correlated variables
```{r}
# For the numeric variables generate a table of correlations

ds %>%
  correlate() %>%
  shave() %>%
  fashion()

ds %>%
  correlate() %>%
  rearrange() %>%
  rplot()

ds %>%
  corrr::correlate() %>%
  shave() %>%
  stretch() %>%
  filter(abs(r) > 0.90)

ds %>%
  correlate() %>%
  rearrange() %>% 
  focus(age_at_mri) 


ds %>%
  correlate() %>%
  network_plot()
```
Missing values
```{r}
# Count the number of missing values.

ds %>% is.na() %>% sum()

# No missing values in the first two columns (INDDID and diagnosis)

ds[1:2] %>% is.na() %>% sum()

ds$education %<>% na.roughfix()

# Confirm that no missing values remain.

ds %>% is.na() %>% sum()
```

Save cleaned dataframe for future use
```{r}
saveRDS(ds, file = here("objects/ashs_clean.RDS"))
```


# Results

## Density Plots numerical variables
```{r, results = 'asis'}
ds %>%
  keep(is.numeric) %>%                     # Keep only numeric columns
  gather() %>%                             # Convert to key-value pairs
  ggplot(aes(value)) +  
  theme(axis.text.x = element_text(size = 4)) +
  facet_wrap(~ key, scales = "free") +   # In separate panels
    geom_histogram() + 
  theme(strip.text.x = element_text(size = 6))
```


## Boxplots  numerical variables
```{r, results = 'asis'}
ds %>%
  keep(is.numeric) %>%                     # Keep only numeric columns
  gather() %>%                             # Convert to key-value pairs
  ggplot(aes(value)) +                     # Plot the values
    facet_wrap(~ key, scales = "free") + 
    stat_boxplot(geom = "errorbar", width = 0.5) + # In separate panels
    geom_boxplot()              +            # boxplot
  theme(strip.text.x = element_text(size = 6))+
  theme(axis.text.x = element_text(size = 4))
  
```

## Table 1: Demographics and Clinical Data
```{r Table 1}
#cleaned unadjusted data:
ds

#add labels
label(ds$session_year) <- "Year of MRI"
label(ds$ad_present) <- "AD+"
label(ds$diagnosis) <- "Clinical Diagnosis"
label(ds$age_at_mri) <- "Age"
label(ds$sex) <- "Sex at Birth"
units(ds$education) <- "years"
  
#reorder levels for table display
ds$diagnosis <- factor(ds$diagnosis, 
                                 levels = c("DLB", "PDD", "PD", "Normal"))

ds$race <- fct_collapse(ds$race, White = "White", `Non-White or Unknown` = c("More than One race", "Black or African American",
                                                                       "Asian", "Unknown or Not Reported"))

ds$race <- factor(ds$race, levels = c("White", "Non-White or Unknown"))

ds$ad_present <- as.character(ds$ad_present)
ds$ad_present[ds$diagnosis == "Normal"] <- "Normal"
ds$ad_present %>% table()

ds$ad_present <- factor(ds$ad_present, 
                             levels = c("Normal", "LBD-AD", "LBD+AD"), 
                             labels = c("Control", "LBD-AD", "LBD+AD"))

ds$ad_present %>% table()

#print table
table1(~ age_at_mri + sex + race + education + diagnosis| ad_present, data = ds, topclass="Rtable1-grid", )

df_tbl1_marker <- ds %>% 
  filter(diagnosis!="Normal")

#print table
table1(~ sex + race + age_at_mri + diagnosis + education | ad_present, data = df_tbl1_marker)

remove(df_tbl1_marker)
```


## Figure 1: Subregion Volumes, unadjusted
```{r subregion vols raw}
#obtain order of regions by mean volume 
df_raw_vol <- ds %>% select(inddid, ad_present, contains(c("left_", "right_"))) %>% 
  select(-contains(c("MISC", "Meninges", "icv", "sul"))) %>% 
  pivot_longer(cols = contains(c("left_", "right_")), names_to = "Region", values_to = "Volume") %>% 
  mutate(ad_present = as.factor(ad_present))

df_raw_vol %>% 
  group_by(Region) %>% 
  summarise(Avg_vol = mean(Volume)) %>% arrange(desc(Avg_vol)) 

df_raw_vol$Region <- recode_factor(df_raw_vol$Region, 
                           left_anterior_hippocampus= "L Ant Hip",
                           right_anterior_hippocampus = "R Ant Hip",
                           left_Posterior_hippocampus = "L Post Hip", 
                           right_Posterior_hippocampus = "R Post Hip",
                           left_Br36 = "L Br36",
                           right_Br36 = "R Br36",
                           left_PHC = "L PHC", 
                           right_PHC = "R PHC", 
                           left_Br35 = "L Br35", 
                           right_Br35 = "R Br35",
                           left_ERC = "L ERC", 
                           right_ERC = "R ERC")

df_raw_vol$ad_present <- recode_factor(df_raw_vol$ad_present,
                               Normal = "Control",
                               `FALSE` = "LBD-AD",
                               `TRUE` = "LBD+AD")


plot <- 
  ggplot(df_raw_vol, aes(x = ad_present, y = Volume)) +
  geom_boxplot() + 
  facet_wrap(.~Region, scales = "free") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Subregion Volumes, Unadjusted", 
       y = "Volume (cm^3)",
       x = "Case Status") +
  font("y", size = 15) +
  font("x", size = 15) +
  theme(strip.text.x = element_text(size = 5)) +
  geom_jitter(alpha = 0.2, size =1)

```

```{r interactive subregion volume plot}
# gt(mydata.filter)
# # now with a few more options
# mydata.filter %>%
#   gt() %>%
#   fmt_number(columns=2:4, decimals = 1) %>%
#   tab_header(title = md("**Regulators of skin pathogenesis**"),
#              subtitle = md("*during cutaneous leishmaniasis*")) %>%
#   tab_footnote(
#     footnote = "Deletion or blockaid ameliorates disease in mice",
#     locations = cells_body(
#       columns = geneID,
#       rows = c(6, 7))) %>% 
#   tab_footnote(
#     footnote = "Associated with treatment failure in multiple studies",
#     locations = cells_body(
#       columns = geneID,
#       rows = c(2:9))) %>%
#   tab_footnote(
#     footnote = "Implicated in parasite control",
#     locations = cells_body(
#       columns = geneID,
#       rows = c(2))) %>%
#   tab_source_note(
#     source_note = md("Reference: Amorim *et al*., (2019). DOI: 10.1126/scitranslmed.aar3619"))
# 
# 
# # Make an interactive table using the DT package ----
# datatable(mydata.df[,c(1,12:14)], 
#           extensions = c('KeyTable', "FixedHeader"), 
#           filter = 'top',
#           options = list(keys = TRUE, 
#                          searchHighlight = TRUE, 
#                          pageLength = 10, 
#                          lengthMenu = c("10", "25", "50", "100")))
# 
# # Make an interactive scatter plot with plotly -----
# # begin by storing your ggplot object
# myplot <- ggplot(mydata.df) + 
#   aes(x=healthy.AVG, y=disease.AVG) +
#   geom_point(shape=16, size=1) +
#   ggtitle("disease vs. healthy") +
#   theme_bw()
# 
# #now use the ggplotly function from the plotly package to convert this ggplot object into an interactive plot
# ggplotly(myplot)
# 
# #let's customize this graphic by adding a more informative mouseover tooltip
# myplot <- ggplot(mydata.df) +
#   aes(x=healthy.AVG, y=disease.AVG, 
#       text = paste("Symbol:", geneID)) +
#   geom_point(shape=16, size=1) +
#   ggtitle("disease vs. healthy") +
#   theme_bw()
# 
# ggplotly(myplot)
```

# Regression with unadjusted volumes
Is AD case status a predictor of volume?

```{r regression using unadjusted vols, echo=TRUE}
# create cases_df
cases_df <- ds %>%  select(-contains(c("misc", "meninges"))) %>% filter(!diagnosis %in% c("Normal")) %>% 
  mutate(ad_present = ifelse(ad_present == "LBD+AD", 1,
                              ifelse(ad_present == "LBD-AD", 0,
                                      "NA")))

# Position of variables in data frame to be used in for loop
# region raw volume
vol_start <- grep("left_anterior_hippocampus$", colnames(cases_df)) #column index to begin taking outcome vars
vol_end <- grep("right_ot_sul$", colnames(cases_df)) #column index to end
vol_nvar <- vol_end - vol_start + 1

# shift within df 
out_shift <- vol_start - 1
  
#For loop
dat <- cases_df
out_mod <- vector('list', length(vol_nvar))
i <- vol_start
  
for (i in vol_start:vol_end){
  raw_volume = colnames(dat)[i]
  
mod_1 <- lm(get(raw_volume) ~ ad_present + diagnosis,
      na.action = na.exclude,
      data=dat)

out_mod[[i-out_shift]] <- mod_1
names(out_mod)[i-out_shift] <- paste0("model_", colnames(dat)[i])
}


library(broom)

out_mod_summary <- summary(out_mod[[1]])
out_mod_summary$coefficients %>% as_tibble()
z <- tidy(mod_1, conf.int =T)[2,]
z %>% mutate(region = names(out_mod[1]))

tidy(out_mod[[1]])

names(out_mod[1])

df <- NULL

for (i in 1:length(out_mod)) {
z <- tidy(out_mod[[i]], conf.int =T)[2,]
z <- z %>% mutate(region = names(out_mod[i]))
df <- rbind(df, z)
}

df1 <- df %>% filter(!str_detect(region, pattern = "_sul|_misc|_meninges")) %>%
  arrange(conf.high) %>% 
  mutate(region = str_remove(region, "model_"),
         region = str_replace(region, "_", " ")) %>% 
  select(Region = "region", `Estimate` = "estimate", `S.E.` = "std.error", p = "p.value", `2.5% CI` = "conf.low", 
         `97.5% CI` = "conf.high")

library(kableExtra)
table <- knitr::kable(df1, digits = 4,
  caption = 'Models of Unadjusted Subfield Volumes for +AD and diagnosis')

kable_classic_2(table)

remove(df, df1, z, table, out_mod_summary, vol_end, vol_nvar, vol_start, dat, out, out_mod)
```

# Regression with Adjusted Volumes, before matching
## Calculate adjusted volumes using "predict" based on all controls
```{r}
# Add columns with volumes adjusted for ICV 

ctrl_df <- ds %>% filter(diagnosis == "Normal")
cases_df <- ds %>% filter(diagnosis != "Normal")
regions <- colnames(ds) %>% .[grepl(., pattern = "*.t_.*")] %>% .[1:22] %>% noquote(.)

out <- vector('list', length(regions))
  

for (i in seq_along(regions)) {
out[[i]] <- lm(paste(regions[i], '~', 'left_icv + age_at_mri + sex'), data=ctrl_df)

ctrl_df[ , ncol(ctrl_df) + 1] <- predict(out[[i]], newdata=ctrl_df)

colnames(ctrl_df)[ncol(ctrl_df)] <-  paste0(regions[i], "_adjusted")

cases_df[ , ncol(cases_df) + 1] <- predict(out[[i]], newdata=cases_df)

colnames(cases_df)[ncol(cases_df)] <-  paste0(regions[i], "_adjusted")

}

d2 <- rbind(ctrl_df, cases_df)

#Example correlation for L anterior hippocampus
ggscatter(ctrl_df, x = "left_anterior_hippocampus", y = "left_anterior_hippocampus_adjusted", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "actual volume", ylab = "adjusted volume", title = "Adjusted L anterior Hippocampus Volume (Controls)")

ggscatter(cases_df, x = "left_anterior_hippocampus", y = "left_anterior_hippocampus_adjusted", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "actual volume", ylab = "adjusted volume", title = "Adjusted L anterior Hippocampus Volume (Cases)")


# Correlated variables
# For the numeric variables generate a table of correlations

cases_df %>%
  corrr::correlate() %>%
  shave() %>%
  stretch() %>%
  filter(abs(r) > 0.90) %>% 
  arrange(r)

```

## Regression with adjusted volumes
```{r, echo=TRUE}
# Is AD case status a predictor of volume  

# Position of variables in data frame to be used in for loop
# region raw volume
raw_start <- grep("left_anterior_hippocampus$", colnames(cases_df)) #column index to begin taking outcome vars
raw_end <- grep("right_ot_sul$", colnames(cases_df)) #column index to end
raw_nvar <- raw_end - raw_start + 1

# "exposure" (adjusted region volume)
adjusted_start <- grep("left_anterior_hippocampus_adjusted", colnames(cases_df))
adjusted_end <- grep("right_ot_sul_adjusted", colnames(cases_df))
adjusted_nvar <- adjusted_end - adjusted_start + 1

# shift within df 
shift_index <- adjusted_start - raw_start
out_shift <- raw_start - 1
  
# modify cases_df
cases_df %<>%
  mutate(ad_present = recode(ad_present, `LBD-AD` = "0", `LBD+AD` = "1", Control = NULL)) %>% 
  mutate(ad_present = as.logical(as.numeric(as.character(ad_present))))


#For loop
dat <- cases_df
out_mod <- vector('list', length(raw_nvar))
i <- raw_start

for (i in raw_start:raw_end){
  raw_volume = colnames(dat)[i]
  adjusted_volume = colnames(dat)[i+shift_index]
  
mod_1 <- lm(get(raw_volume) ~ ad_present + get(adjusted_volume),
      na.action = na.exclude,
      data=dat)


#Add new row for each brain region with output from model
out_mod[[i-out_shift]] <- mod_1
names(out_mod)[i-out_shift] <- paste0("model_", colnames(dat)[i])

}
 
library(broom)

df <- NULL

for (i in 1:length(out_mod)) {
z <- tidy(out_mod[[i]], conf.int =T)[2,]
z <- z %>% mutate(region = names(out_mod[i]))
df <- rbind(df, z)
}

df1 <- df %>% filter(!str_detect(region, pattern = "_sul|_misc|_meninges")) %>%
  arrange(conf.high) %>% 
  mutate(region = str_remove(region, "model_"),
         region = str_replace(region, "_", " ")) %>% 
  select(Region = "region", `Estimate` = "estimate", 
         `S.E.` = "std.error", p = "p.value", `2.5% CI` = "conf.low", 
         `97.5% CI` = "conf.high")

library(kableExtra)
table <- knitr::kable(df1, digits = 4,
  caption = 'Models of Adjusted Subfield Volumes for +AD')

kable_classic_2(table)


```




# Matching cases and controls

## Planning 
### Select type of effect to be estimated
Direct effect of "case status" (LBD+/-AD) on MTL volumes

### Selecting a target population
In individuals with LBD

### Selecting covariates to balance
"To estimate total causal effects, all covariates must be measured prior to treatment (or otherwise not be affected by the treatment)"

1. Age at MRI 
2. center recruited from (should encompass different MRI scanners to some extent)
3. Sex
4. Intracranial volume

## Check initial imbalance
## No matching; constructing a pre-match matchit object
Values of standardized mean differences and eCDF statistics close to zero and values of variance ratios close to one indicate good balance.

```{r}
#remove missing covariates for MatchIt
d_for_matchit <- ds %>% 
  filter(is.na(education)==F) %>% 
  mutate(case_status = ifelse(diagnosis == "Normal", 0, 1))

m.out0 <- matchit(case_status ~ 
                    age_at_mri +
                    sex +
                    left_icv +
                    session_year +  #add recruitment location here 
                    education,
                  data = d_for_matchit,
                 method = NULL, distance = "glm")

# Checking balance prior to matching
summary(m.out0)

```

## 1:1 NN PS matching w/o replacement
```{r}
# I removed race since there were very few in each group
m.out1 <- matchit(case_status ~ 
                    age_at_mri +
                    sex +
                    left_icv + #add recruitment location here 
                    session_year +
                    education,
                  data = d_for_matchit,
                 method = "nearest", distance = "glm")


m.out1
```
### Assessing the Quality of Matches
Although matching on the propensity score is often effective at eliminating differences between the treatment groups to achieve covariate balance, its performance in this regard must be assessed. If covariates remain imbalanced after matching, the matching is considered unsuccessful, and a different matching specification should be tried. MatchIt offers a few tools for the assessment of covariate balance after matching. These include graphical and statistical methods. More detail on the interpretation of the included plots and statistics can be found in vignette("assessing-balance").

In addition to covariate balance, the quality of the match is determined by how many units remain after matching. Matching often involves discarding units that are not paired with other units, and some matching options, such as setting restrictions for common support or calipers, can further decrease the number of remaining units. If, after matching, the remaining sample size is small, the resulting effect estimate may be imprecise. In many cases, there will be a trade-off between balance and remaining sample size. How to optimally choose among them is an instance of the fundamental bias-variance trade-off problem that cannot be resolved without substantive knowledge of the phenomena under study. Prospective power analyses can be used to determine how small a sample can be before necessary precision is sacrificed.

To assess the quality of the resulting matches numerically, we can use the summary() function on m.out1 as before. Here we set un = FALSE to suppress display of the balance before matching for brevity and because we already saw it. (Leaving it as TRUE, its default, would display balance both before and after matching.)

```{r}
# Checking balance after NN matching
summary(m.out1, un = TRUE)

```
Next is a table of the sample sizes before and after matching. The matching procedure left a certain number of control units unmatched. Ideally, unmatched units would be those far from the treated units and would require greater extrapolation were they to have been retained. We can visualize the distribution of propensity scores of those who were matched using plot() with type = "jitter":

```{r}
plot(m.out1, type = "jitter", interactive = FALSE)
```
We can visually examine balance on the covariates using plot() with type = "qq":
```{r}
plot(m.out1, type = "qq", interactive = FALSE,
     which.xs = c("age_at_mri", "sex", "left_icv"))

#eCDF plot
plot(m.out1, type = "ecdf", interactive = FALSE,
     which.xs = c("age_at_mri", "sex", "left_icv"))

#density plot
plot(m.out1, type = "density", interactive = FALSE,
     which.xs = c("age_at_mri", "sex", "left_icv"))

```
Points far from the solid diagonal line are the areas of the covariate distributions that differ between the treatment groups. 

```{r}

s.out <- matchit(case_status ~ 
                    age_at_mri +
                    sex +
                    left_icv +
                    session_year +
                    education,
                  data = d_for_matchit,
                 method = "subclass", subclass = 4)

s.out

summary(s.out)

summary(s.out, subclass = TRUE, un = FALSE)

s <- summary(s.out, subclass = TRUE)
plot(s, var.order = "unmatched", abs = FALSE)


plot(s.out, type = "density", which.xs = c("age_at_mri", "sex", "left_icv"),
     subclass = 4)
```


```{r}
library(optmatch)
library(cobalt)
# Full matching on a probit PS
m.out2 <- matchit(case_status ~ 
                    age_at_mri +
                    sex +
                    left_icv + #add recruitment location here 
                    session_year +
                    education,
                  data = d_for_matchit,
                 method = "full", distance = "glm", link = "probit")
m.out2
```
We can examine balance on this new matching specification.

## Checking balance after full matching
```{r}
summary(m.out2, un = FALSE)
plot(summary(m.out2))

#Vs partial matching
plot(summary(m.out1))


plot(m.out2, type = "qq", interactive = FALSE,
     which.xs = c("age_at_mri", "sex", "left_icv"))

#eCDF plot
plot(m.out2, type = "ecdf", interactive = FALSE,
     which.xs = c("age_at_mri", "sex", "left_icv"))

#density plot
plot(m.out2, type = "density", interactive = FALSE,
     which.xs = c("age_at_mri", "sex", "left_icv"))

```

How treatment effects are estimated depends on what form of matching was performed. See vignette("estimating-effects") for information on the variety of way to estimate effects and standard errors after each type of matching and for several outcome types. With continuous outcomes, it is often a good idea to also include the covariates used in the matching in the effect estimation, as doing so can provide additional robustness to slight imbalances remaining after the matching and can improve precision.
We’ll demonstrate here how to estimate a treatment effect after performing such an analysis. First, we’ll extract the matched dataset from the matchit object using match.data(). This dataset only contains the matched units and adds columns for distance, weights, and subclass (described previously
 
```{r}
mF <- m.out2
md <- match.data(mF)  #full matching with probit linking function

head(md)

```
We can then estimate a treatment effect in this dataset using the standard regression functions in R, like lm() or glm(), being sure to include the matching weights (stored in the weights variable of the match.data() output) in the estimation3. We recommend using cluster-robust standard errors for most analyses, with pair membership as the clustering variable; the lmtest and sandwich packages together make this straightforward.

```{r}
library("lmtest") #coeftest
library("sandwich") #vcovCL

fit1 <- lm(left_anterior_hippocampus ~ case_status,
           data = md, 
           weights = weights)


coeftest(fit1, vcov. = vcovCL, cluster = ~subclass)


```

## With covariate adjustment
As previously mentioned, it is generally acceptable to include just the main effects, but including interactions between the treatment and covariates can be beneficial when effect modification by the covariates may be present. Because we have not demonstrated this strategy so far, we demonstrate it below.

In order to interpret the coefficient on treatment as a marginal effect estimate, we need to center the covariates at their means in the target population (i.e., the original sample for the ATE, the treated units for the ATT, or the retained units for an ATM); we could also use a marginal effects procedure as has been demonstrated with binary outcomes for other matching methods. Below we use the strategy of centering the covariates at their means. Note that when factor predictors are present, they need to be split into dummy (0/1) variables prior to centering. The splitfactor() function in cobalt can make this straightforward. Although this procedure is more involved compared to simply including main effects, it can provide extra precision and robustness.

```{r}
#Estimating a covariate-adjusted marginal effect
#with treatment-covariate interactions

#Create a new dataset for centered variables
md_cen <- splitfactor(md, "sex")

covs_to_center <- c("sex_Male", "age_at_mri",
                    "left_icv", #add recruitment location here 
                    "session_year",
                    "education")
md_cen[covs_to_center] <- scale(md_cen[covs_to_center], 
                                scale = FALSE)

#Fit the model with every covariate interacting with treatment
fit2 <- lm(left_anterior_hippocampus ~ case_status * (age_at_mri +
                    sex_Male +
                    left_icv +  #add recruitment location here 
                    session_year +
                    education),
           data = md_cen, weights = weights)

#Only output the intercept and coefficient on treatment
# coeftest(fit2, vcov. = vcovCL, cluster = ~subclass)[1:2,]
```

# Adjusted subregion volumes
To create adjusted subregion volumes, use matched controls' volumes to predict case's subfield volumes
```{r adjusted vols for all regions}

#Create a new dataset for centered variables
md_cen <- splitfactor(md, "sex")

#main "treatment" effect is icv ("left_icv"), so center everything else

covs_to_center <- c("sex_Male", "age_at_mri") #consider adding recruitment location here

md_cen[covs_to_center] <- scale(md_cen[covs_to_center], 
                                scale = FALSE)

d <- md_cen

ctrl_df <- d %>% filter(diagnosis == "Normal")
cases_df <- d %>% filter(diagnosis != "Normal")
regions <- colnames(d) %>% .[grepl(., pattern = "*.t_.*")] %>% .[1:22] %>% noquote(.)

out <- vector('list', length(regions))
  

for (i in seq_along(regions)) {
out[[i]] <- lm(paste(regions[i], '~', 'left_icv * (sex_Male + age_at_mri)'), data=ctrl_df, weights = weights)

ctrl_df[ , ncol(ctrl_df) + 1] <- predict(out[[i]], newdata=ctrl_df)

colnames(ctrl_df)[ncol(ctrl_df)] <-  paste0(regions[i], "_adjusted")

cases_df[ , ncol(cases_df) + 1] <- predict(out[[i]], newdata=cases_df)

colnames(cases_df)[ncol(cases_df)] <-  paste0(regions[i], "_adjusted")

}

d2 <- rbind(ctrl_df, cases_df)

d2$ad_present[d2$diagnosis =="Normal"] <- "Normal"

#Example correlation for L anterior hippocampus
ggscatter(ctrl_df, x = "left_anterior_hippocampus", y = "left_anterior_hippocampus_adjusted", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "actual volume", ylab = "adjusted volume", title = "Adjusted L anterior Hippocampus Volume (Controls)")

ggscatter(cases_df, x = "left_anterior_hippocampus", y = "left_anterior_hippocampus_adjusted", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "actual volume", ylab = "adjusted volume", title = "Adjusted L anterior Hippocampus Volume (Cases)")

remove(d)
```



```{r boxplot of adjusted volumes}
library(ggplot2)

#obtain order of regions by mean volume 
d2 %>% select(INDDID, ad_present, ends_with("_adjusted")) %>% 
  select(-contains(c("MISC", "Meninges"))) %>% 
  pivot_longer(cols = ends_with("_adjusted"), names_to = "Region", values_to = "Volume") %>% 
  group_by(Region) %>% 
  summarise(Avg_vol = mean(Volume)) %>% arrange(desc(Avg_vol)) 

#boxplot for all regions
df <- d2 %>% select(INDDID, ad_present, ends_with("_adjusted")) %>% 
  select(-contains(c("MISC", "Meninges"))) %>% 
  select(left_anterior_hippocampus_adjusted, right_anterior_hippocampus_adjusted, left_Posterior_hippocampus_adjusted, right_Posterior_hippocampus_adjusted, ad_present, 
left_Br36_adjusted, right_Br36_adjusted, right_PHC_adjusted, left_PHC_adjusted, left_Br35_adjusted, left_ERC_adjusted, right_ERC_adjusted, right_Br35_adjusted, INDDID) %>% 
  pivot_longer(cols = ends_with("_adjusted"), names_to = "Region", values_to = "Volume") %>% 
  mutate(ad_present = as.factor(ad_present))

df$Region <- recode_factor(df$Region, 
                           left_anterior_hippocampus_adjusted = "L Ant Hip",
                           right_anterior_hippocampus_adjusted = "R Ant Hip",
                           left_Posterior_hippocampus_adjusted = "L Post Hip", 
                           right_Posterior_hippocampus_adjusted = "R Post Hip",
                           left_Br36_adjusted = "L Br36",
                           right_Br36_adjusted = "R Br36",
                           left_PHC_adjusted = "L PHC", 
                           right_PHC_adjusted = "R PHC", 
                           left_Br35_adjusted = "L Br35", 
                           right_Br35_adjusted = "R Br35",
                           left_ERC_adjusted = "L ERC", 
                           right_ERC_adjusted = "R ERC")

df$ad_present <- recode_factor(df$ad_present,
                               Normal = "Control",
                               `FALSE` = "LBD-AD",
                               `TRUE` = "LBD+AD")


ggplot(df, aes(x = ad_present, y = Volume)) +
  geom_boxplot() + 
  facet_wrap(.~Region, scales = "free") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Subregion Volumes Adjusted for Age, sex, and icv", 
       y = "Volume (cm^3)",
       x = "Case Status") +
  font("y", size = 15) +
  font("x", size = 15) +
  theme(strip.text.x = element_text(size = 15)) +
  geom_jitter(alpha = 0.2, size =1)


```

# Table 1 after matching
```{r Table 1 after matching}
#add in demographics
df_tbl1 <- 
  md %>% 
  left_join(demographics) %>% 
  select(INDDID, diagnosis, case_status, ad_marker, intvl_marker, ad_present, session_year, sex, race, YOB, education, Deceased) %>% 
  group_by(INDDID) %>% 
  mutate(ad_present = ad_present[!is.na(ad_present)][1L]) %>% 
  distinct() %>% 
  ungroup() %>% 
  filter(is.na(education)==F) %>% 
  filter(education > 1)


df_tbl1$age_at_mri <- df_tbl1$session_year - df_tbl1$YOB

#add labels
label(df_tbl1$ad_marker) <- "AD Marker"

label(df_tbl1$intvl_marker) <- "AD Marker to MRI"
label(df_tbl1$session_year) <- "Year of MRI"
label(df_tbl1$ad_present) <- "AD+"
label(df_tbl1$diagnosis) <- "Clinical Diagnosis"
label(df_tbl1$age_at_mri) <- "Age"
label(df_tbl1$sex) <- "sex at Birth"

units(df_tbl1$education) <- "years"
units(df_tbl1$intvl_marker) <- "years"
  
#reorder levels for table display
df_tbl1$diagnosis <- factor(df_tbl1$diagnosis, 
                                 levels = c("DLB", "PDD", "PD", "Normal"))

df_tbl1$ad_marker <- factor(df_tbl1$ad_marker, 
                                 levels = c(Autopsy = "autopsy", PET = "pet", CSF ="csf"))

df_tbl1$race <- fct_collapse(df_tbl1$race, White = "White", `Non-White or Unknown` = c("More than One race", "Black or African American",
                                                                       "Asian", "Unknown or Not Reported"))

df_tbl1$race <- factor(df_tbl1$race, levels = c("White", "Non-White or Unknown"))

df_tbl1$ad_present[df_tbl1$diagnosis=="Normal"] <- "Normal"

df_tbl1$ad_present <- factor(df_tbl1$ad_present, 
                             levels = c("Normal", "FALSE", "TRUE"), 
                             labels = c("Control", "LBD-AD", "LBD+AD"))
 
table1(~ age_at_mri + sex + race + education + diagnosis| ad_present, data = df_tbl1, topclass="Rtable1-grid")

df_tbl1_marker <- df_tbl1 %>% 
  filter(diagnosis!="Normal")




table1(~ sex + race + age_at_mri + diagnosis + ad_marker + education + Deceased | ad_present, data = df_tbl1_marker)
```
